<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polycarbonate</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    
    <!-- Font loading -->
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Crimson Text", "Times New Roman", serif;
        }

        body {
            background: #000;
            min-height: 100vh;
            overflow: hidden;
        }

        .title-wrapper {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            transition: top 0.3s ease;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .title-wrapper.visible {
            opacity: 1;
        }

        body.loaded {
            opacity: 1;
        }

        .parallax-container {
            position: fixed;
            width: 50vw;
            height: 50vh;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(2);
            transform-origin: center;
            perspective: 1000px;
            transform-style: preserve-3d;
            z-index: 1;
            opacity: 0;
            transition: opacity 1s ease-in;
        }

        .layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-style: preserve-3d;
            will-change: transform;
            transition: transform 0.1s ease-out;
            width: 100%;
            height: 100%;
            visibility: visible;
            filter: none;
        }

        #parallax-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        #layer1 {
            width: 100%;
            height: 100%;
            transform: translate(-50%, -50%) translateZ(0px) scale(1.2);
            filter: blur(8px);
        }

        #layer2 {
            width: 100%;
            height: 100%;
            transform: translate(-50%, -50%) translateZ(0px) scale(1.2);
            filter: blur(2px);
        }

        #layer3 {
            width: 100%;
            height: 100%;
            transform: translate(-50%, -50%) translateZ(0px) scale(1.2);
        }

        .layer img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            pointer-events: none;
            backface-visibility: hidden;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .layer img.loaded {
            opacity: 1;
        }

        .content {
            position: relative;
            min-height: 400vh;
            z-index: 2;
        }

        .content-section {
            position: relative;
            height: 100vh;
            width: 100%;
        }

        #noise {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.05;
            z-index: 1000;
            image-rendering: pixelated;
            transition: opacity 0.3s ease;
        }

        #antialias {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            backdrop-filter: blur(0.5px);
        }

        .darkening-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2;
            pointer-events: none;
        }

        .static-noise {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.1;
            z-index: 3;
            mix-blend-mode: screen;
            transition: opacity 0.3s ease;
        }

        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:wght@700&display=swap');

        .title-wrapper {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            transition: top 0.3s ease;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #title-canvas {
            image-rendering: pixelated;
            transform: scale(4);
            transform-origin: center;
            margin: 0 auto;
        }

        .title-container {
            position: fixed;
            top: 0;
            left: 0;
                width: 100%;
                height: 100%;
            display: flex;
                align-items: center;
            justify-content: center;
            z-index: 998;
            transform: scale(2);
            transform-origin: 0 0;
            image-rendering: pixelated;
        }

        .chevron-wrapper {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 998;
            transition: all 0.3s ease;
            opacity: 1;
            cursor: pointer;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #chevron-canvas {
            image-rendering: pixelated;
            transform: scale(4);
            transform-origin: center;
        }

        .fade-in {
            opacity: 1;
        }

        .chevron-hidden {
            opacity: 0;
            transform: translate(-50%, 100%);
            pointer-events: none;
            display: none;
        }

        .bio-wrapper {
            position: fixed;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .bio-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.3s ease;
            image-rendering: pixelated;
            pointer-events: none;
        }

        #bio-bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
                width: 100%;
                height: 100%;
            image-rendering: pixelated;
        }

        #bio-canvas {
            image-rendering: pixelated;
            transform: scale(4);
            transform-origin: center;
        }

        .robotics-wrapper {
                position: fixed;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #robotics-canvas {
            image-rendering: pixelated;
            transform: scale(4);
            transform-origin: center;
            pointer-events: none;
            cursor: default;
        }

        .kana-wrapper {
            position: fixed;
            top: 65%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 998;
            opacity: 0;
            transition: opacity 0.3s ease;
                width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
        }

        #kana-canvas {
            image-rendering: pixelated;
            transform: scale(4);
            transform-origin: center;
            max-height: 65vh;
            width: auto;
            pointer-events: none;
            cursor: default;
        }

        .indicator-wrapper {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 998;
            opacity: 0;
            transition: opacity 0.3s ease;
            cursor: pointer;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #indicator-canvas {
            image-rendering: pixelated;
            transform: scale(4);
            transform-origin: center;
                display: block;
            height: 10px;
        }

        .nav-dots {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 999;
            display: flex;
                flex-direction: column;
            gap: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .nav-dot {
            width: 32px;
            height: 32px;
                position: relative;
            cursor: pointer;
            image-rendering: pixelated;
        }

        .nav-dot canvas {
            position: absolute;
            top: 0;
            left: 0;
                width: 100%;
            height: 100%;
            transform-origin: center;
            image-rendering: pixelated;
        }

        .robotics-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.3s ease;
            image-rendering: pixelated;
            pointer-events: none;
        }

        #robotics-bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        @media (max-width: 768px) {
            .parallax-container {
                pointer-events: none;
            }

            .content {
                min-height: 400vh;
            }

            #title-canvas,
            #bio-canvas,
            #robotics-canvas,
            #indicator-canvas {
                transform: scale(2) !important;
                transform-origin: center;
                margin: 0 auto;
            }

            #kana-canvas {
                transform: scale(2) !important;
                transform-origin: center;
                margin: 0 auto;
            }

            .title-wrapper {
                width: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                transform: translate(-50%, -50%);
                opacity: 0;
                transition: opacity 0.3s ease;
            }

            .title-wrapper.moved {
                top: 5% !important;
                transform: translate(-50%, 0);
            }

            .bio-wrapper,
            .robotics-wrapper {
                width: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .indicator-wrapper {
                display: none !important;
            }

            .chevron-wrapper {
                bottom: 20px;
                width: 100%;
            }

            .chevron-hidden {
                display: none !important;
            }

            body {
                overflow: hidden;
            }

            .nav-dots {
                display: none !important;
            }
            
            .bio-wrapper {
                top: 55% !important;
            }

            .robotics-wrapper {
                top: 35% !important;
            }

            .kana-wrapper {
                top: 65% !important;
                width: 100%;
                display: flex;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="title-wrapper">
        <canvas id="title-canvas"></canvas>
    </div>
    <div class="bio-wrapper">
        <canvas id="bio-canvas"></canvas>
    </div>
    <div class="robotics-wrapper">
        <canvas id="robotics-canvas"></canvas>
    </div>
    <div class="kana-wrapper">
        <canvas id="kana-canvas"></canvas>
    </div>
    <div class="indicator-wrapper">
        <canvas id="indicator-canvas"></canvas>
    </div>
    <div class="chevron-wrapper">
        <canvas id="chevron-canvas"></canvas>
    </div>
    <div id="antialias"></div>
    <canvas id="noise"></canvas>
    <canvas class="static-noise"></canvas>
    <div class="darkening-overlay"></div>
    <div class="parallax-container">
        <canvas id="parallax-canvas"></canvas>
        <div class="layer" id="layer1">
            <img src="layer1.png" alt="Background Layer">
        </div>
        <div class="layer" id="layer2">
            <img src="layer2.png" alt="Middle Layer">
        </div>
        <div class="layer" id="layer3">
            <img src="layer3.png" alt="Foreground Layer">
        </div>
    </div>
    <div class="content">
        <section class="content-section"></section>
        <section class="content-section"></section>
        <section class="content-section"></section>
        <section class="content-section"></section>
    </div>
    <div class="nav-dots">
        <div class="nav-dot" data-section="0"><canvas></canvas></div>
        <div class="nav-dot" data-section="1"><canvas></canvas></div>
        <div class="nav-dot" data-section="2"><canvas></canvas></div>
    </div>
    <div class="bio-background">
        <canvas id="bio-bg-canvas"></canvas>
    </div>
    <div class="robotics-background">
        <canvas id="robotics-bg-canvas"></canvas>
    </div>
    <div class="loading-overlay"></div>

    <script>
        // Simple font loading check
        document.fonts.ready.then(() => {
            setupTitle();
            document.querySelector('.title-wrapper').classList.add('visible');
        });

        // Preload images before DOM content loads
        const imagesToPreload = [
            'layer1.png',
            'layer2.png',
            'layer3.png',
            'bliss.png',
            'kana.png',
            'ocean.jpg'
        ].map(img => {
            const resolution = getImageResolution();
            return `optimized/${img.split('.')[0]}_${resolution}.${img.split('.')[1]}`;
        });

        // Load all resources in parallel
        Promise.all([
            ...imagesToPreload.map(src => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = resolve;
                    img.onerror = () => {
                        console.warn(`Failed to load optimized image ${src}, falling back to original`);
                        const originalImg = new Image();
                        originalImg.onload = resolve;
                        originalImg.onerror = reject;
                        originalImg.src = src.replace(/optimized\/(.+)_(720p|1080p|2k|4k)\./, '$1.');
                    };
                    img.src = src;
                });
            })
        ]).catch(error => {
            console.error('Error loading resources:', error);
        });

        document.addEventListener('DOMContentLoaded', async () => {
            // Set up canvas dimensions and initial content immediately
            setupNoise();
            setupTitle();
            setupChevron();
            requestAnimationFrame(drawNoise);
            requestAnimationFrame(drawChevron);

            // Start loading backgrounds immediately
            initBackgrounds();

            try {
                // Initialize all elements
                setupParallax();
                setupBio();
                setupRobotics();
                setupIndicator();
                setupParallaxCanvas();
                setupNavDots();
                animate();

                // Show content
                document.querySelector('.parallax-container').style.opacity = '1';
                document.querySelector('.title-wrapper').style.opacity = '1';
                document.querySelector('.chevron-wrapper').style.opacity = '1';
            } catch (error) {
                console.error('Error during initialization:', error);
            }
        });

        // Update window resize handler
        window.addEventListener('resize', () => {
            if (window.backgroundImages) {
                const bioCanvas = document.getElementById('bio-bg-canvas');
                const bioCtx = bioCanvas.getContext('2d');
                drawBackground(bioCanvas, bioCtx, window.backgroundImages.bioBg);

                const roboticsCanvas = document.getElementById('robotics-bg-canvas');
                const roboticsCtx = roboticsCanvas.getContext('2d');
                drawBackground(roboticsCanvas, roboticsCtx, window.backgroundImages.oceanBg);
            }

            // Update noise canvas
            const noiseCanvas = document.getElementById('noise');
            noiseCanvas.width = Math.floor(window.innerWidth / 4);
            noiseCanvas.height = Math.floor(window.innerHeight / 4);
        });

        async function setupParallax() {
            const layer1 = document.getElementById('layer1').querySelector('img');
            const layer2 = document.getElementById('layer2').querySelector('img');
            const layer3 = document.getElementById('layer3').querySelector('img');

            // Get optimized paths
            const resolution = getImageResolution();
            
            // Add load handlers before setting src
            [layer1, layer2, layer3].forEach(img => {
                img.onload = () => img.classList.add('loaded');
            });

            layer1.src = `optimized/layer1_${resolution}.png`;
            layer2.src = `optimized/layer2_${resolution}.png`;
            layer3.src = `optimized/layer3_${resolution}.png`;
        }

        // Initialize backgrounds
        async function initBackgrounds() {
            try {
                const resolution = getImageResolution();
                const bioBg = new Image();
                const oceanBg = new Image();
                
                // Set up bio background
                const bioCanvas = document.getElementById('bio-bg-canvas');
                const bioCtx = bioCanvas.getContext('2d');
                
                // Set up robotics background
                const roboticsCanvas = document.getElementById('robotics-bg-canvas');
                const roboticsCtx = roboticsCanvas.getContext('2d');

                // Load bio background
                bioBg.onload = () => {
                    drawBackground(bioCanvas, bioCtx, bioBg);
                    window.backgroundImages = window.backgroundImages || {};
                    window.backgroundImages.bioBg = bioBg;
                };
                bioBg.src = `optimized/bliss_${resolution}.png`;

                // Load ocean background
                oceanBg.onload = () => {
                    drawBackground(roboticsCanvas, roboticsCtx, oceanBg);
                    window.backgroundImages = window.backgroundImages || {};
                    window.backgroundImages.oceanBg = oceanBg;
                };
                oceanBg.src = `optimized/ocean_${resolution}.jpg`;

                // Add error handlers
                bioBg.onerror = () => {
                    console.warn('Failed to load bio background, trying original');
                    bioBg.src = 'bliss.png';
                };
                oceanBg.onerror = () => {
                    console.warn('Failed to load ocean background, trying original');
                    oceanBg.src = 'ocean.jpg';
                };
            } catch (error) {
                console.error('Error initializing backgrounds:', error);
            }
        }

        // Function to draw background
        function drawBackground(canvas, ctx, img) {
            if (!img.complete) return;
            
            const scale = 4;
            canvas.width = Math.floor(window.innerWidth / scale);
            canvas.height = Math.floor(window.innerHeight / scale);
            ctx.imageSmoothingEnabled = false;
            
            // Calculate scaling to fill BOTH dimensions
            const scaleX = canvas.width / img.width;
            const scaleY = canvas.height / img.height;
            const scaleFactor = Math.max(scaleX, scaleY);
            
            // Calculate dimensions that will overflow the canvas
            const drawWidth = img.width * scaleFactor;
            const drawHeight = img.height * scaleFactor;
            
            // Center the image
            const offsetX = (canvas.width - drawWidth) / 2;
            const offsetY = (canvas.height - drawHeight) / 2;
            
            // Draw the image scaled up to fill everything
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // DOM Element References - moved to top
        const noise = document.getElementById('noise');
        const ctx = noise.getContext('2d', { antialias: false });
        const staticNoise = document.querySelector('.static-noise');
        const staticCtx = staticNoise.getContext('2d', { antialias: false });
        const container = document.querySelector('.parallax-container');
        const layers = document.querySelectorAll('.layer');
        const images = document.querySelectorAll('img');
        const parallaxCanvas = document.getElementById('parallax-canvas');
        const parallaxCtx = parallaxCanvas.getContext('2d', { antialias: false });
        const parallaxContainer = document.querySelector('.parallax-container');
        const titleCanvas = document.getElementById('title-canvas');
        const titleCtx = titleCanvas.getContext('2d');
        const bioCanvas = document.getElementById('bio-canvas');
        const bioCtx = bioCanvas.getContext('2d');
        const bioWrapper = document.querySelector('.bio-wrapper');
        const roboticsCanvas = document.getElementById('robotics-canvas');
        const roboticsCtx = roboticsCanvas.getContext('2d');
        const roboticsWrapper = document.querySelector('.robotics-wrapper');
        const kanaCanvas = document.getElementById('kana-canvas');
        const kanaCtx = kanaCanvas.getContext('2d');
        const kanaWrapper = document.querySelector('.kana-wrapper');
        const chevronCanvas = document.getElementById('chevron-canvas');
        const chevronCtx = chevronCanvas.getContext('2d');
        const indicatorCanvas = document.getElementById('indicator-canvas');
        const indicatorCtx = indicatorCanvas.getContext('2d');
        const indicatorWrapper = document.querySelector('.indicator-wrapper');
        const titleWrapper = document.querySelector('.title-wrapper');
        const darkeningOverlay = document.querySelector('.darkening-overlay');
        const chevronWrapper = document.querySelector('.chevron-wrapper');
        const bioBackground = document.querySelector('.bio-background');
        const bioBgCanvas = document.getElementById('bio-bg-canvas');
        const bioBgCtx = bioBgCanvas.getContext('2d');
        const roboticsBackground = document.querySelector('.robotics-background');
        const roboticsBgCanvas = document.getElementById('robotics-bg-canvas');
        const roboticsBgCtx = roboticsBgCanvas.getContext('2d');

        // Animation and State Variables
        const FPS = 30;
        const frameDelay = 1000 / FPS;
        const PARALLAX_FPS = 24;
        const PARALLAX_FRAME_DELAY = 1000 / PARALLAX_FPS;
        let lastDrawTime = 0;
        let lastParallaxTime = 0;
        let needsParallaxUpdate = false;
        let rafId = null;
        let isMoving = false;
        let moveTimeout = null;
        let mouseX = 0;
        let mouseY = 0;
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let currentX = 0;
        let currentY = 0;
        let targetX = 0;
        let targetY = 0;
        let chevronOffset = 0;

        // Section Navigation Variables
        let currentSection = 0;
        const sections = [
            { name: 'title', position: 0 },
            { name: 'bio', position: 1 },
            { name: 'robotics', position: 2 }
        ];
        let isScrolling = false;
        let scrollTimeout = null;
        let lastScrollTime = 0;
        const scrollCooldown = 300;
        let isAnimating = false;

        // Touch Variables
        let touchStartY = 0;
        let touchEndY = 0;
        const minSwipeDistance = 50;

        // Scroll handling variables
        let lastWheelTime = 0;
        let wheelTimeout = null;
        let accumulatedDelta = 0;
        let isScrollLocked = false;
        const scrollLockDuration = 800; // Time to lock scrolling after a section change
        const scrollResetTimeout = 300; // Time to reset accumulated delta if no new scroll events
        const minDeltaThreshold = 10;  // Minimum delta to start accumulating
        const sectionChangeThreshold = 35; // Delta threshold to trigger section change

        // Film noise effect functions
        function setupNoise() {
            noise.width = Math.floor(window.innerWidth / 4);
            noise.height = Math.floor(window.innerHeight / 4);
            ctx.imageSmoothingEnabled = false;

            staticNoise.width = window.innerWidth;
            staticNoise.height = window.innerHeight;
            staticCtx.imageSmoothingEnabled = false;
        }
        
        function drawNoise(currentTime) {
            if (!lastDrawTime) lastDrawTime = currentTime;
            const elapsed = currentTime - lastDrawTime;

            if (elapsed > frameDelay) {
                // Film grain noise
                const imageData = ctx.createImageData(noise.width, noise.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const value = Math.random() * 255;
                    data[i] = value;     // red
                    data[i + 1] = value; // green
                    data[i + 2] = value; // blue
                    data[i + 3] = 255;   // alpha
                }
                
                ctx.putImageData(imageData, 0, 0);

                // Static noise
                const staticData = staticCtx.createImageData(staticNoise.width, staticNoise.height);
                const sData = staticData.data;
                
                for (let i = 0; i < sData.length; i += 4) {
                    const value = Math.random() > 0.97 ? 255 : 0; // More sparse noise
                    sData[i] = value;     // red
                    sData[i + 1] = value; // green
                    sData[i + 2] = value; // blue
                    sData[i + 3] = value; // alpha
                }
                
                staticCtx.putImageData(staticData, 0, 0);
                lastDrawTime = currentTime;
            }
            
            requestAnimationFrame(drawNoise);
        }

        // Setup parallax canvas
        function setupParallaxCanvas() {
            parallaxCanvas.width = Math.floor(container.clientWidth);
            parallaxCanvas.height = Math.floor(container.clientHeight);
            parallaxCtx.imageSmoothingEnabled = false;
            needsParallaxUpdate = true;
        }

        function renderParallax(currentTime) {
            if (!needsParallaxUpdate) {
                if (isMoving) {
                    rafId = requestAnimationFrame(renderParallax);
                }
                return;
            }
            
            if (!lastParallaxTime) lastParallaxTime = currentTime;
            const elapsed = currentTime - lastParallaxTime;
            
            if (elapsed < PARALLAX_FRAME_DELAY) {
                rafId = requestAnimationFrame(renderParallax);
                return;
            }

            // Clear the canvas
            parallaxCtx.clearRect(0, 0, parallaxCanvas.width, parallaxCanvas.height);
            
            // Calculate center position in the canvas
            const centerX = parallaxCanvas.width / 2;
            const centerY = parallaxCanvas.height / 2;

            // Draw each layer
            layers.forEach((layer, index) => {
                const img = images[index];
                const moveX = currentX * (index + 1) * 0.5;
                const moveY = currentY * (index + 1) * 0.5;
                
                // Calculate position
                const x = centerX + moveX;
                const y = centerY + moveY;
                
                // Calculate dimensions to maintain aspect ratio while filling
                const scale = 1.2;
                const containerAspect = parallaxCanvas.width / parallaxCanvas.height;
                const imageAspect = img.naturalWidth / img.naturalHeight;
                
                let width, height;
                if (containerAspect > imageAspect) {
                    width = parallaxCanvas.width * scale;
                    height = width / imageAspect;
                } else {
                    height = parallaxCanvas.height * scale;
                    width = height * imageAspect;
                }
                
                // Apply blur based on layer
                if (index === 0) {
                    parallaxCtx.filter = 'blur(8px)';
                } else if (index === 1) {
                    parallaxCtx.filter = 'blur(2px)';
                } else {
                    parallaxCtx.filter = 'none';
                }
                
                // Draw image directly
                parallaxCtx.drawImage(img, 
                    x - width/2, y - height/2, 
                    width, height
                );
            });

            lastParallaxTime = currentTime;
            needsParallaxUpdate = false;
            
            if (isMoving) {
                rafId = requestAnimationFrame(renderParallax);
            }
        }

        // Wait for both fonts and images
        Promise.all([
            document.fonts.ready,
            ...Array.from(images).map(img => {
                return new Promise((resolve, reject) => {
                    if (img.complete) {
                        resolve();
                    } else {
                        img.onload = resolve;
                        img.onerror = reject;
                    }
                });
            })
        ]).then(() => {
            setupText();
            setupBio();
            setupRobotics();
            setupIndicator();
            setupChevron();
            setupParallaxCanvas();
            setupNavDots();
            parallaxContainer.classList.add('fade-in');
            animate();

            // Start chevron animation
            requestAnimationFrame(drawChevron);
        }).catch(error => {
            console.error('Error loading resources:', error);
        });

        function drawChevron() {
            // Clear the canvas
            chevronCtx.clearRect(0, 0, chevronCanvas.width, chevronCanvas.height);
            
            // Calculate vertical offset using sine wave
            chevronOffset = Math.sin(Date.now() / 500) * 2;
            
            // Draw the chevron
            chevronCtx.strokeStyle = '#ffd280';
            chevronCtx.lineWidth = 2;
            chevronCtx.beginPath();
            chevronCtx.moveTo(4, 6 + chevronOffset);
            chevronCtx.lineTo(10, 12 + chevronOffset);
            chevronCtx.lineTo(16, 6 + chevronOffset);
            chevronCtx.stroke();

            // Add glow effect
            chevronCtx.shadowColor = 'rgba(255, 176, 0, 0.9)';
            chevronCtx.shadowBlur = 2;
            chevronCtx.stroke();

            requestAnimationFrame(drawChevron);
        }

        // Update section handling
        function updateSection(newSection) {
            if (isAnimating) return;
            isAnimating = true;
            
            const vh = window.innerHeight;
            const isMobile = window.innerWidth <= 768;
            currentSection = newSection;
            
            // Title movement and darkening
            if (currentSection >= 1) {
            if (isMobile) {
                    titleWrapper.classList.add('moved');
                } else {
                    titleWrapper.style.top = '10%';
                }
                darkeningOverlay.style.opacity = '0.85';
                chevronWrapper.classList.add('chevron-hidden');
                parallaxContainer.style.opacity = '0';
                noise.style.opacity = '0';
                staticNoise.style.opacity = '0';
                document.querySelector('.nav-dots').style.opacity = '1';
            } else {
                if (isMobile) {
                    titleWrapper.classList.remove('moved');
                } else {
                    titleWrapper.style.top = '50%';
                }
                darkeningOverlay.style.opacity = '0';
                chevronWrapper.classList.remove('chevron-hidden');
                parallaxContainer.style.opacity = '1';
                noise.style.opacity = '0.05';
                staticNoise.style.opacity = '0.1';
                document.querySelector('.nav-dots').style.opacity = '0';
            }
            
            // Bio section
            if (currentSection === 1) {
                bioWrapper.style.opacity = '1';
                bioWrapper.style.top = '55%';
                roboticsWrapper.style.opacity = '0';
                kanaWrapper.style.opacity = '0';
                indicatorWrapper.style.opacity = '1';
                bioBackground.style.opacity = '1';
                roboticsBackground.style.opacity = '0';
                
                // Redraw bio background
                if (window.backgroundImages && window.backgroundImages.bioBg) {
                    const bioCanvas = document.getElementById('bio-bg-canvas');
                    const bioCtx = bioCanvas.getContext('2d');
                    drawBackground(bioCanvas, bioCtx, window.backgroundImages.bioBg);
                }
                
                // Disable click events
                kanaCanvas.style.pointerEvents = 'none';
                roboticsCanvas.style.pointerEvents = 'none';
                kanaCanvas.style.cursor = 'default';
                roboticsCanvas.style.cursor = 'default';
                
                setupBio(); // Re-render bio text
            }
            // Robotics section
            else if (currentSection === 2) {
                bioWrapper.style.opacity = '0';
                roboticsWrapper.style.opacity = '1';
                roboticsWrapper.style.top = '25%';
                kanaWrapper.style.opacity = '1';
                kanaWrapper.style.top = '65%';
                indicatorWrapper.style.opacity = '0';
                bioBackground.style.opacity = '0';
                roboticsBackground.style.opacity = '1';
                
                // Redraw robotics background
                if (window.backgroundImages && window.backgroundImages.oceanBg) {
                    const roboticsCanvas = document.getElementById('robotics-bg-canvas');
                    const roboticsCtx = roboticsCanvas.getContext('2d');
                    drawBackground(roboticsCanvas, roboticsCtx, window.backgroundImages.oceanBg);
                }
                
                // Enable click events only on robotics page
                kanaCanvas.style.pointerEvents = 'auto';
                roboticsCanvas.style.pointerEvents = 'auto';
                kanaCanvas.style.cursor = 'pointer';
                
                setupRobotics(); // Re-render robotics text
            }
            // Title section
            else {
                bioWrapper.style.opacity = '0';
                roboticsWrapper.style.opacity = '0';
                kanaWrapper.style.opacity = '0';
                indicatorWrapper.style.opacity = '0';
                bioBackground.style.opacity = '0';
                roboticsBackground.style.opacity = '0';
            }
            
            // Re-render indicator text
            setupIndicator();
            
            // After animation completes
            setTimeout(() => {
                isAnimating = false;
            }, 300); // Match this with your CSS transition duration
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            // Redraw backgrounds if they exist
            if (window.backgroundImages) {
                if (window.backgroundImages.bioBg) {
                    const bioCanvas = document.getElementById('bio-bg-canvas');
                    const bioCtx = bioCanvas.getContext('2d');
                    drawBackground(bioCanvas, bioCtx, window.backgroundImages.bioBg);
                }
                if (window.backgroundImages.oceanBg) {
                    const roboticsCanvas = document.getElementById('robotics-bg-canvas');
                    const roboticsCtx = roboticsCanvas.getContext('2d');
                    drawBackground(roboticsCanvas, roboticsCtx, window.backgroundImages.oceanBg);
                }
            }

            // Update noise canvas
            const noiseCanvas = document.getElementById('noise');
            noiseCanvas.width = Math.floor(window.innerWidth / 4);
            noiseCanvas.height = Math.floor(window.innerHeight / 4);
        });

        window.addEventListener('mousemove', (e) => {
            if (window.innerWidth <= 768) return; // Disable parallax on mobile
            
            mouseX = (e.clientX - windowWidth / 2);
            mouseY = (e.clientY - windowHeight / 2);
            
            // Increase sensitivity by 1.5x (from 4 to 6)
            targetX = (mouseX / windowWidth) * 6;
            targetY = (mouseY / windowHeight) * 6;

            isMoving = true;
            needsParallaxUpdate = true;

            // Clear existing timeout
            if (moveTimeout) {
                clearTimeout(moveTimeout);
            }

            // Start animation if not running
            if (!rafId) {
                rafId = requestAnimationFrame(renderParallax);
            }

            // Set timeout to stop animation
            moveTimeout = setTimeout(() => {
                isMoving = false;
                rafId = null;
            }, 100);
        });

        // Scroll handling
        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const currentTime = Date.now();
            
            // If we're animating or scroll is locked, ignore the scroll
            if (isAnimating || isScrollLocked) {
                return;
            }
            
            // Normalize the delta based on deltaMode
            let normalizedDelta;
            switch (e.deltaMode) {
                case 0: // Pixels
                    normalizedDelta = e.deltaY * 0.3; // Reduce sensitivity for pixel-based delta
                    break;
                case 1: // Lines
                    normalizedDelta = e.deltaY * 8;
                    break;
                case 2: // Pages
                    normalizedDelta = e.deltaY * 24;
                    break;
            }

            // Only accumulate if the delta is significant enough
            if (Math.abs(normalizedDelta) > minDeltaThreshold) {
                accumulatedDelta += normalizedDelta;
            }

            // Clear existing timeout
            if (wheelTimeout) {
                clearTimeout(wheelTimeout);
            }

            // Set timeout to reset accumulated delta if no scroll occurs
            wheelTimeout = setTimeout(() => {
                accumulatedDelta = 0;
            }, scrollResetTimeout);

            // Check if we should trigger a section change
            if (Math.abs(accumulatedDelta) >= sectionChangeThreshold) {
                const scrollDown = accumulatedDelta > 0;
                let nextSection = currentSection;
                
                if (scrollDown && currentSection < sections.length - 1) {
                    nextSection++;
                } else if (!scrollDown && currentSection > 0) {
                    nextSection--;
                }
                
                if (nextSection !== currentSection) {
                    updateSection(nextSection);
                    
                    // Lock scrolling temporarily
                    isScrollLocked = true;
                    setTimeout(() => {
                        isScrollLocked = false;
                    }, scrollLockDuration);
                }

                // Reset accumulated delta after triggering
                accumulatedDelta = 0;
            }
        }, { passive: false });

        // Handle touch events for mobile
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener('touchend', (e) => {
            const currentTime = Date.now();
            
            // If we're in cooldown, ignore the touch
            if (currentTime - lastScrollTime < scrollCooldown) {
                return;
            }
            
            touchEndY = e.changedTouches[0].clientY;
            const swipeDistance = touchEndY - touchStartY;
            
            if (Math.abs(swipeDistance) >= minSwipeDistance) {
                const scrollDown = swipeDistance < 0;
                
                let nextSection = currentSection;
                if (scrollDown && currentSection < sections.length - 1) {
                    nextSection++;
                } else if (!scrollDown && currentSection > 0) {
                    nextSection--;
                }
                
                if (nextSection !== currentSection) {
                    updateSection(nextSection);
                    lastScrollTime = currentTime;
                        }
                    }
                });
                
        // Add smooth transitions to elements
        const elementsToTransition = [
            titleWrapper, bioWrapper, roboticsWrapper, 
            kanaWrapper, indicatorWrapper, parallaxContainer,
            darkeningOverlay, noise, staticNoise
        ];

        elementsToTransition.forEach(element => {
            element.style.transition = 'all 0.3s ease-out';
        });

        function animate(currentTime) {
            const oldX = currentX;
            const oldY = currentY;

            currentX += (targetX - currentX) * 0.1;
            currentY += (targetY - currentY) * 0.1;

            // Update layer positions using CSS transforms
            layers.forEach((layer, index) => {
                const moveX = currentX * (index + 1);
                const moveY = currentY * (index + 1);
                layer.style.transform = `translate(-50%, -50%) translate(${moveX}px, ${moveY}px) scale(1.2)`;
            });

            requestAnimationFrame(animate);
        }

        // Text rendering
        function setupText() {
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 18 : 20;
            
            titleCanvas.width = Math.floor(window.innerWidth * (isMobile ? 0.8 : 0.9));
            titleCanvas.height = Math.floor(window.innerHeight * (isMobile ? 0.2 : 0.15));
            titleCtx.imageSmoothingEnabled = false;
            
            const text = isMobile ? ["hey, i'm", "polycarbonate"] : ["hey, i'm polycarbonate"];
            const lineHeight = fontSize * 1.5;
            const totalHeight = text.length * lineHeight;
            const startY = titleCanvas.height / 2 - (totalHeight / 2) + (lineHeight / 2);

            titleCtx.textAlign = 'center';
            titleCtx.textBaseline = 'middle';
            titleCtx.font = `${fontSize}px "Crimson Text"`;

            text.forEach((line, i) => {
                const centerX = titleCanvas.width / 2;
                const centerY = startY + (i * lineHeight);

                // Draw dark outline first
                titleCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                titleCtx.lineWidth = 3;
                titleCtx.strokeText(line, centerX, centerY);
                
                // Draw outer glow layers
                titleCtx.fillStyle = 'rgba(255, 140, 0, 0.3)';
                titleCtx.shadowColor = 'rgba(255, 140, 0, 0.3)';
                titleCtx.shadowBlur = 8;
                titleCtx.fillText(line, centerX, centerY);

                titleCtx.fillStyle = 'rgba(255, 140, 0, 0.5)';
                titleCtx.shadowColor = 'rgba(255, 140, 0, 0.5)';
                titleCtx.shadowBlur = 6;
                titleCtx.fillText(line, centerX, centerY);

                titleCtx.fillStyle = 'rgba(255, 140, 0, 0.7)';
                titleCtx.shadowColor = 'rgba(255, 140, 0, 0.7)';
                titleCtx.shadowBlur = 4;
                titleCtx.fillText(line, centerX, centerY);

                // Draw main text with brightest glow
                titleCtx.fillStyle = '#ffd280';
                titleCtx.shadowColor = 'rgba(255, 176, 0, 0.9)';
                titleCtx.shadowBlur = 2;
                titleCtx.fillText(line, centerX, centerY);

                // Final pass without shadow for crisp text
                titleCtx.shadowBlur = 0;
                titleCtx.fillText(line, centerX, centerY);
            });
        }

        // Chevron rendering
        function setupChevron() {
            chevronCanvas.width = 20;
            chevronCanvas.height = 20;
            chevronCtx.imageSmoothingEnabled = false;
        }

        // Bio text rendering
        function setupBio() {
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 14 : 20;
            const lineHeight = isMobile ? 20 : 25;
            
            bioCanvas.width = Math.floor(window.innerWidth * (isMobile ? 0.7 : 0.9));
            bioCanvas.height = Math.floor(window.innerHeight * (isMobile ? 0.2 : 0.25));
            bioCtx.imageSmoothingEnabled = false;
            
            const text = isMobile ? [
                "an aspiring and passionate",
                "mechanical engineer based",
                "in California. I love robots,",
                "computers, music, and",
                "touching grass."
            ] : [
                "an aspiring and passionate mechanical engineer",
                "based in California. I love robots, computers,",
                "music, and touching grass."
            ];
            
            const startY = bioCanvas.height / 2 - ((text.length - 1) * lineHeight) / 2;

            bioCtx.textAlign = 'center';
            bioCtx.textBaseline = 'middle';
            bioCtx.font = `${fontSize}px "Crimson Text"`;

            // First pass - draw grass blades and glows
            text.forEach((line, i) => {
                const centerX = bioCanvas.width / 2;
                const centerY = startY + i * lineHeight;

                bioCtx.shadowBlur = 4;
                
                if (line.includes('grass')) {
                    // Split the line at 'grass'
                    const parts = line.split(/\b(grass)\b/);
                    let currentX = centerX - bioCtx.measureText(line).width / 2;
                    
                    parts.forEach(part => {
                        if (part === 'grass') {
                            bioCtx.fillStyle = '#90EE90';
                            bioCtx.shadowColor = 'rgba(144, 238, 144, 0.8)';
                            
                            // Draw the text
                            const grassX = currentX + bioCtx.measureText(part).width / 2;
                            bioCtx.fillText(part, grassX, centerY);
                            
                            // Draw animated grass blades
                            bioCtx.strokeStyle = '#90EE90';
                            bioCtx.lineWidth = 1;
                            const bladeCount = 24;
                            const wordWidth = bioCtx.measureText(part).width;
                            
                            // Create natural clumps of grass
                            const clumpCount = 5;
                            const bladesPerClump = Math.floor(bladeCount / clumpCount);
                            
                            // Shift entire grass effect right (reduced from 6 to 3)
                            const grassShift = 3;
                            
                            for (let clump = 0; clump < clumpCount; clump++) {
                                // Alternate base angles for clumps to create natural variation
                                const clumpBaseAngle = (clump % 2 === 0 ? 1 : -1) * 
                                    (0.3 + Math.sin(clump * 8.123) * 0.2); // Alternating left/right angles
                                
                                // Calculate clump center with organic variation
                                const clumpCenter = grassX - wordWidth/2 + 
                                    (clump * wordWidth/clumpCount) + 
                                    (Math.sin(clump * 3.789) * wordWidth/clumpCount * 0.2) + 
                                    grassShift; // Add right shift
                                
                                // Each clump has slightly different height characteristics
                                const clumpHeight = 3 + Math.sin(clump * 5.234) * 1;
                                
                                for (let j = 0; j < bladesPerClump; j++) {
                                    // Create tight clusters within each clump
                                    const clusterOffset = (j - bladesPerClump/2) * 1.2;
                                    const randomOffset = Math.sin(j * 8.37 + clump * 2.54) * 1.2;
                                    
                                    // Add some random spread to each blade within the clump
                                    const spreadX = Math.sin(j * 7.123 + clump * 4.567) * 1.5;
                                    const spreadY = Math.abs(Math.sin(j * 9.234 + clump * 3.456)) * 1;
                                    
                                    const bladeX = clumpCenter + clusterOffset + randomOffset + spreadX;
                                    
                                    // Multiple wave patterns for organic movement
                                    const time = Date.now() / 1000;
                                    const fastWave = Math.sin(time * 2 + j * 0.7 + clump * 0.5) * 0.3;
                                    const slowWave = Math.sin(time * 0.5 + j * 0.4 + clump * 0.3) * 0.5;
                                    const microWave = Math.sin(time * 4 + j * 1.2 + clump * 0.8) * 0.1;
                                    
                                    // Each blade has its own angle variation
                                    const individualAngle = (Math.sin(j * 7.89 + clump * 3.45) * 0.3) * 
                                        (j % 2 === 0 ? 1 : -1); // Alternate angles within clump
                                    const totalAngle = clumpBaseAngle + individualAngle;
                                    
                                    // Varied heights within the clump
                                    const bladeHeight = clumpHeight + spreadY + 
                                        fastWave + slowWave + Math.abs(microWave) * 2;
                                    
                                    // Combine waves for natural swaying
                                    const swayX = (fastWave + slowWave * 0.7 + microWave) * 
                                        (1 + Math.abs(totalAngle));
                                    
                                    bioCtx.beginPath();
                                    bioCtx.moveTo(bladeX, centerY - 3);
                                    
                                    // Create curved blade with natural bending
                                    const cp1x = bladeX + Math.cos(totalAngle) * 2 + swayX;
                                    const cp1y = centerY - 3 - bladeHeight * 0.4;
                                    const cp2x = bladeX + Math.cos(totalAngle) * 3 + swayX * 0.7;
                                    const cp2y = centerY - 3 - bladeHeight * 0.8;
                                    
                                    const endX = bladeX + Math.cos(totalAngle) * 4 + swayX * 0.3;
                                    const endY = centerY - 3 - bladeHeight - 1;
                                    
                                    bioCtx.bezierCurveTo(
                                        cp1x, cp1y,
                                        cp2x, cp2y,
                                        endX, endY
                                    );
                                    bioCtx.stroke();
                                }
                        }
                    } else {
                            bioCtx.fillStyle = '#ffffff';
                            bioCtx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                            bioCtx.fillText(part, currentX + bioCtx.measureText(part).width / 2, centerY);
                        }
                        currentX += bioCtx.measureText(part).width;
                    });
                } else {
                    bioCtx.fillStyle = '#ffffff';
                    bioCtx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    bioCtx.fillText(line, centerX, centerY);
                }
            });

            // Second pass - crisp text without shadows
            bioCtx.shadowBlur = 0;
            text.forEach((line, i) => {
                const centerX = bioCanvas.width / 2;
                const centerY = startY + i * lineHeight;

                if (line.includes('grass')) {
                    // Split the line at 'grass'
                    const parts = line.split(/\b(grass)\b/);
                    let currentX = centerX - bioCtx.measureText(line).width / 2;
                    
                    parts.forEach(part => {
                        bioCtx.fillStyle = part === 'grass' ? '#90EE90' : '#ffffff';
                        bioCtx.fillText(part, currentX + bioCtx.measureText(part).width / 2, centerY);
                        currentX += bioCtx.measureText(part).width;
                    });
                } else {
                    bioCtx.fillStyle = '#ffffff';
                    bioCtx.fillText(line, centerX, centerY);
                }
            });

            // Request next animation frame for continuous grass animation
            requestAnimationFrame(setupBio);
        }

        // Setup robotics text and kana image
        const kanaImage = new Image();
        kanaImage.src = 'kana.png';

        // Wait for kana image to load
        kanaImage.onload = function() {
            setupKana();
        };

        function setupKana() {
            const isMobile = window.innerWidth <= 768;
            // Calculate dimensions to fit the image within screen bounds while maintaining aspect ratio
            const maxHeight = Math.floor(window.innerHeight * (isMobile ? 0.6 : 0.65) / (isMobile ? 2 : 4));
            const maxWidth = Math.floor(window.innerWidth * (isMobile ? 1.2 : 1) / (isMobile ? 2 : 4));
            
            // Calculate scale based on both height and width constraints
            const scaleHeight = maxHeight / kanaImage.height;
            const scaleWidth = maxWidth / kanaImage.width;
            const scale = Math.min(scaleHeight, scaleWidth);
            
            const targetWidth = Math.floor(kanaImage.width * scale);
            const targetHeight = Math.floor(kanaImage.height * scale);

            kanaCanvas.width = targetWidth;
            kanaCanvas.height = targetHeight;
            kanaCtx.imageSmoothingEnabled = false;
            
            // Draw the image
            kanaCtx.drawImage(kanaImage, 0, 0, targetWidth, targetHeight);
        }

        function setupRobotics() {
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 14 : 20;
            
            roboticsCanvas.width = Math.floor(window.innerWidth * (isMobile ? 0.7 : 0.9));
            roboticsCanvas.height = Math.floor(window.innerHeight * (isMobile ? 0.15 : 0.2));
            roboticsCtx.imageSmoothingEnabled = false;
            
            const text = isMobile ? 
                ["check out my robotics", "team, triple fault:"] :
                ["check out my robotics team, ", "triple fault", ":"];

            const centerX = roboticsCanvas.width / 2;
            const centerY = roboticsCanvas.height / 2;
            const lineHeight = fontSize * 1.5;

            roboticsCtx.textAlign = 'center';
            roboticsCtx.textBaseline = 'middle';

            if (isMobile) {
                // Mobile layout
                text.forEach((line, i) => {
                    const y = centerY + (i - 0.5) * lineHeight;
                    if (line.includes('triple fault')) {
                        const parts = line.split(/(triple fault)/);
                        let currentX = centerX - roboticsCtx.measureText(line).width / 2;
                        
                        parts.forEach(part => {
                            if (part === 'triple fault') {
                                roboticsCtx.font = `bold ${fontSize}px "Crimson Text"`;
                                const tfX = currentX + roboticsCtx.measureText(part).width / 2;
                                drawTextWithGlow(part, tfX, y, true);
                                
                                // Store click area
                                const tfWidth = roboticsCtx.measureText(part).width;
                                roboticsWrapper.clickArea = {
                                    x: tfX - tfWidth/2,
                                    y: y - fontSize/2,
                                    width: tfWidth,
                                    height: fontSize
                                };
                } else {
                                roboticsCtx.font = `${fontSize}px "Crimson Text"`;
                                drawTextWithGlow(part, currentX + roboticsCtx.measureText(part).width / 2, y, false);
                            }
                            currentX += roboticsCtx.measureText(part).width;
                        });
                    } else {
                        roboticsCtx.font = `${fontSize}px "Crimson Text"`;
                        drawTextWithGlow(line, centerX, y, false);
                    }
                });
            } else {
                // Desktop layout (existing code)
                roboticsCtx.font = `${fontSize}px "Crimson Text"`;
                const normalWidth = roboticsCtx.measureText(text[0]).width;
                roboticsCtx.font = `bold ${fontSize}px "Crimson Text"`;
                const boldWidth = roboticsCtx.measureText(text[1]).width;
                roboticsCtx.font = `${fontSize}px "Crimson Text"`;
                const colonWidth = roboticsCtx.measureText(text[2]).width;
                const totalWidth = normalWidth + boldWidth + colonWidth;
                
                let currentX = centerX - totalWidth / 2;

                roboticsCtx.font = `${fontSize}px "Crimson Text"`;
                drawTextWithGlow(text[0], currentX + roboticsCtx.measureText(text[0]).width / 2, centerY, false);
                currentX += roboticsCtx.measureText(text[0]).width;

                roboticsCtx.font = `bold ${fontSize}px "Crimson Text"`;
                const tfX = currentX + roboticsCtx.measureText(text[1]).width / 2;
                drawTextWithGlow(text[1], tfX, centerY, true);
                
                const tfWidth = roboticsCtx.measureText(text[1]).width;
                roboticsWrapper.clickArea = {
                    x: tfX - tfWidth/2,
                    y: centerY - fontSize/2,
                    width: tfWidth,
                    height: fontSize
                };
                
                currentX += roboticsCtx.measureText(text[1]).width;

                roboticsCtx.font = `${fontSize}px "Crimson Text"`;
                drawTextWithGlow(text[2], currentX + roboticsCtx.measureText(text[2]).width / 2, centerY, false);
            }
        }

        function drawTextWithGlow(text, x, y, isBold) {
            // Draw dark outline first
            roboticsCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            roboticsCtx.lineWidth = isBold ? 4 : 3;
            roboticsCtx.strokeText(text, x, y);
            
            // Draw outer glow layers
            const glowIntensity = isBold ? 0.4 : 0.3;
            roboticsCtx.fillStyle = `rgba(190, 170, 255, ${glowIntensity})`;
            roboticsCtx.shadowColor = `rgba(190, 170, 255, ${glowIntensity})`;
            roboticsCtx.shadowBlur = 8;
            roboticsCtx.fillText(text, x, y);

            roboticsCtx.fillStyle = `rgba(190, 170, 255, ${glowIntensity + 0.2})`;
            roboticsCtx.shadowColor = `rgba(190, 170, 255, ${glowIntensity + 0.2})`;
            roboticsCtx.shadowBlur = 6;
            roboticsCtx.fillText(text, x, y);

            roboticsCtx.fillStyle = `rgba(190, 170, 255, ${glowIntensity + 0.4})`;
            roboticsCtx.shadowColor = `rgba(190, 170, 255, ${glowIntensity + 0.4})`;
            roboticsCtx.shadowBlur = 4;
            roboticsCtx.fillText(text, x, y);

            // Draw main text with brightest glow
            roboticsCtx.fillStyle = '#e0d5ff';
            roboticsCtx.shadowColor = 'rgba(190, 170, 255, 0.9)';
            roboticsCtx.shadowBlur = 2;
            roboticsCtx.fillText(text, x, y);

            // Final pass without shadow for crisp text
            roboticsCtx.shadowBlur = 0;
            roboticsCtx.fillText(text, x, y);
        }

        // Add click handler for robotics text
        roboticsWrapper.addEventListener('click', (e) => {
            // Only trigger if on robotics page (section 2) and clicking the canvas
            if (currentSection !== 2 || e.target !== roboticsCanvas) return;
            
            const rect = roboticsCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / (window.innerWidth <= 768 ? 2 : 4);
            const y = (e.clientY - rect.top) / (window.innerWidth <= 768 ? 2 : 4);
            
            if (roboticsWrapper.clickArea && 
                x >= roboticsWrapper.clickArea.x && 
                x <= roboticsWrapper.clickArea.x + roboticsWrapper.clickArea.width &&
                y >= roboticsWrapper.clickArea.y && 
                y <= roboticsWrapper.clickArea.y + roboticsWrapper.clickArea.height) {
                window.location.href = 'https://3fault.com';
            }
        });

        // Update mousemove handler for robotics text
        roboticsWrapper.addEventListener('mousemove', (e) => {
            // Only show pointer if on robotics page (section 2)
            if (currentSection !== 2 || e.target !== roboticsCanvas) {
                roboticsWrapper.style.cursor = 'default';
                return;
            }
            
            const rect = roboticsCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / (window.innerWidth <= 768 ? 2 : 4);
            const y = (e.clientY - rect.top) / (window.innerWidth <= 768 ? 2 : 4);
            
            if (roboticsWrapper.clickArea && 
                x >= roboticsWrapper.clickArea.x && 
                x <= roboticsWrapper.clickArea.x + roboticsWrapper.clickArea.width &&
                y >= roboticsWrapper.clickArea.y && 
                y <= roboticsWrapper.clickArea.y + roboticsWrapper.clickArea.height) {
                roboticsWrapper.style.cursor = 'pointer';
            } else {
                roboticsWrapper.style.cursor = 'default';
            }
        });

        // Add content divs to make scrolling work
        const content = document.querySelector('.content');
        const spacer = document.createElement('div');
        spacer.style.height = '100vh';
        content.appendChild(spacer);

        // Setup indicator text
        function setupIndicator() {
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 16 : 16;
            
            // Calculate text width first
            const text = currentSection === 1 ? "up next: robotics" : "";
            if (!text) return;

            // Create temporary context to measure text
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.font = `${fontSize}px "Crimson Text"`;
            const textWidth = tempCtx.measureText(text).width;
            
            // Set canvas dimensions based on text size
            indicatorCanvas.width = Math.ceil(textWidth) + 8;
            indicatorCanvas.height = Math.ceil(fontSize * 1.2);
            indicatorCtx.imageSmoothingEnabled = false;
            
            const centerX = indicatorCanvas.width / 2;
            const centerY = indicatorCanvas.height / 2;

            indicatorCtx.textAlign = 'center';
            indicatorCtx.textBaseline = 'middle';
            indicatorCtx.font = `${fontSize}px "Crimson Text"`;

            // Draw dark outline first
            indicatorCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            indicatorCtx.lineWidth = 3;
            indicatorCtx.strokeText(text, centerX, centerY);
            
            // Purple theme for robotics section
            const nextSectionColor = { color: '#e0d5ff', alpha: '190, 170, 255' };
            
            // Draw outer glow layers
            indicatorCtx.fillStyle = `rgba(${nextSectionColor.alpha}, 0.3)`;
            indicatorCtx.shadowColor = `rgba(${nextSectionColor.alpha}, 0.3)`;
            indicatorCtx.shadowBlur = 8;
            indicatorCtx.fillText(text, centerX, centerY);

            indicatorCtx.fillStyle = `rgba(${nextSectionColor.alpha}, 0.5)`;
            indicatorCtx.shadowColor = `rgba(${nextSectionColor.alpha}, 0.5)`;
            indicatorCtx.shadowBlur = 6;
            indicatorCtx.fillText(text, centerX, centerY);

            indicatorCtx.fillStyle = `rgba(${nextSectionColor.alpha}, 0.7)`;
            indicatorCtx.shadowColor = `rgba(${nextSectionColor.alpha}, 0.7)`;
            indicatorCtx.shadowBlur = 4;
            indicatorCtx.fillText(text, centerX, centerY);

            // Draw main text with brightest glow
            indicatorCtx.fillStyle = nextSectionColor.color;
            indicatorCtx.shadowColor = `rgba(${nextSectionColor.alpha}, 0.9)`;
            indicatorCtx.shadowBlur = 2;
            indicatorCtx.fillText(text, centerX, centerY);

            // Final pass without shadow for crisp text
            indicatorCtx.shadowBlur = 0;
            indicatorCtx.fillText(text, centerX, centerY);
        }

        // Navigation dot setup and drawing
        const navDots = document.querySelectorAll('.nav-dot');
        
        function setupNavDots() {
            navDots.forEach((dot, index) => {
                const canvas = dot.querySelector('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size to match display size for proper pixel density
                canvas.width = 8;
                canvas.height = 8;
                ctx.imageSmoothingEnabled = false;

                // Draw the dot
                function drawDot(active) {
                    ctx.clearRect(0, 0, 8, 8);
                    
                    // Colors for each section
                    const colors = [
                        { fill: '#b3d9ff', glow: 'rgba(179, 217, 255, 0.8)' },  // Pastel blue
                        { fill: '#90EE90', glow: 'rgba(144, 238, 144, 0.8)' },  // Green
                        { fill: '#e0d5ff', glow: 'rgba(190, 170, 255, 0.8)' }   // Purple
                    ];
                    
                    // Draw glow if active
                    if (active) {
                        ctx.shadowColor = colors[index].glow;
                        ctx.shadowBlur = 1;
                    }
                    
                    // Draw dot
                    ctx.fillStyle = colors[index].fill;
                    ctx.beginPath();
                    ctx.arc(4, 4, active ? 3 : 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Clear shadow
                    ctx.shadowBlur = 0;
                }

                // Initial draw
                drawDot(currentSection === index);

                // Add click handler
                dot.addEventListener('click', () => {
                    if (currentSection !== index) {
                        updateSection(index);
                    }
                });

                // Store draw function for updates
                dot.draw = drawDot;
            });
        }

        // Update dots when section changes
        const originalUpdateSection = updateSection;
        updateSection = function(newSection) {
            originalUpdateSection(newSection);
            
            // Update dot appearances
            navDots.forEach((dot, index) => {
                dot.draw(index === newSection);
            });
        };

        // Function to determine appropriate image resolution
        function getImageResolution() {
            const width = window.screen.width * window.devicePixelRatio;
            const height = window.screen.height * window.devicePixelRatio;
            
            if (width <= 1280 || height <= 720) return '720p';
            if (width <= 1920 || height <= 1080) return '1080p';
            if (width <= 2560 || height <= 1440) return '2k';
            return '4k';
        }

        // Function to get optimized image path
        function getOptimizedImagePath(originalPath) {
            const resolution = getImageResolution();
            const ext = originalPath.split('.').pop();
            const baseName = originalPath.split('/').pop().split('.')[0];
            return `optimized/${baseName}_${resolution}.${ext}`;
        }

        // Preload images function
        async function preloadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        // Load optimized images
        async function loadOptimizedImages() {
            const imagesToLoad = [
                'layer1.png',
                'layer2.png',
                'layer3.png',
                'bliss.png',
                'kana.png',
                'ocean.jpg'
            ];

            const loadedImages = {};
            
            for (const image of imagesToLoad) {
                try {
                    const optimizedPath = getOptimizedImagePath(image);
                    loadedImages[image] = await preloadImage(optimizedPath);
                } catch (error) {
                    console.warn(`Failed to load optimized image ${image}, falling back to original`);
                    loadedImages[image] = await preloadImage(image);
                }
            }

            return loadedImages;
        }

        // Add click handlers
        indicatorWrapper.addEventListener('click', () => {
            if (currentSection < sections.length - 1) {
                updateSection(currentSection + 1);
            }
        });

        chevronWrapper.addEventListener('click', () => {
            if (currentSection === 0) {
                updateSection(1);
            }
        });

        kanaWrapper.addEventListener('click', (e) => {
            // Only trigger if clicking the canvas itself
            if (e.target === kanaCanvas) {
                window.location.href = 'https://3fault.com';
            }
        });

        kanaWrapper.addEventListener('mouseover', () => {
            kanaWrapper.style.cursor = 'pointer';
        });

        // Setup title text
        function setupTitle() {
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 18 : 20;
            
            titleCanvas.width = Math.floor(window.innerWidth * (isMobile ? 0.8 : 0.9));
            titleCanvas.height = Math.floor(window.innerHeight * (isMobile ? 0.2 : 0.15));
            titleCtx.imageSmoothingEnabled = false;
            
            const text = isMobile ? ["hey, i'm", "polycarbonate"] : ["hey, i'm polycarbonate"];
            const lineHeight = fontSize * 1.5;
            const totalHeight = text.length * lineHeight;
            const startY = titleCanvas.height / 2 - (totalHeight / 2) + (lineHeight / 2);

            titleCtx.textAlign = 'center';
            titleCtx.textBaseline = 'middle';
            titleCtx.font = `${fontSize}px "Crimson Text"`;

            text.forEach((line, i) => {
                const centerX = titleCanvas.width / 2;
                const centerY = startY + (i * lineHeight);

                // Draw dark outline first
                titleCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                titleCtx.lineWidth = 3;
                titleCtx.strokeText(line, centerX, centerY);
                
                // Draw outer glow layers
                titleCtx.fillStyle = 'rgba(255, 140, 0, 0.3)';
                titleCtx.shadowColor = 'rgba(255, 140, 0, 0.3)';
                titleCtx.shadowBlur = 8;
                titleCtx.fillText(line, centerX, centerY);

                titleCtx.fillStyle = 'rgba(255, 140, 0, 0.5)';
                titleCtx.shadowColor = 'rgba(255, 140, 0, 0.5)';
                titleCtx.shadowBlur = 6;
                titleCtx.fillText(line, centerX, centerY);

                titleCtx.fillStyle = 'rgba(255, 140, 0, 0.7)';
                titleCtx.shadowColor = 'rgba(255, 140, 0, 0.7)';
                titleCtx.shadowBlur = 4;
                titleCtx.fillText(line, centerX, centerY);

                // Draw main text with brightest glow
                titleCtx.fillStyle = '#ffd280';
                titleCtx.shadowColor = 'rgba(255, 176, 0, 0.9)';
                titleCtx.shadowBlur = 2;
                titleCtx.fillText(line, centerX, centerY);

                // Final pass without shadow for crisp text
                titleCtx.shadowBlur = 0;
                titleCtx.fillText(line, centerX, centerY);
            });
        }
    </script>
</body>
</html>